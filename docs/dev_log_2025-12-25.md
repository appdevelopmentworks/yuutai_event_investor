# 開発ログ: 2025-12-25

**実装日:** 2025-12-25
**バージョン:** v1.1.0
**ステータス:** ✅ 完了

---

## 📋 実装内容サマリー

本日は、v1.0.0リリース後の改善作業として、以下の4つの主要タスクを実装しました：

1. **設定変更時のキャッシュ自動無効化機能**
2. **チャート表示バグの修正**
3. **詳細パネルのUI/UX改善**
4. **データ更新機能の実装**

---

## 🔧 詳細実装内容

### 1. 設定変更時のキャッシュ自動無効化機能 ✅

#### 問題
ユーザーが設定画面でデータ取得期間を「10年」から「全期間」に変更しても、既存の`simulation_cache`テーブルにデータ取得期間が保存されていないため、キャッシュされた古い結果が表示され続ける問題がありました。

#### 解決策
**実装ファイル:** `src/ui/main_window_v3.py`

**追加メソッド:**
- `_load_settings()` - settings.jsonから現在の設定を読み込み
- `_get_default_settings()` - デフォルト設定を返す
- `_get_period_value()` - 期間文字列（"10y", "max"等）を数値に変換
- `_clear_simulation_cache()` - simulation_cacheテーブルを全削除し、データをリロード

**実装ロジック:**
```python
def on_settings_changed(self, settings: Dict[str, Any]):
    # 現在の設定と新しい設定を比較
    old_period = self._get_period_value(self.current_settings.get('data_period', '10y'))
    new_period = self._get_period_value(settings.get('data_period', '10y'))

    # 期間が増えた場合（例: 10年 → 全期間）
    if new_period > old_period:
        # ユーザーに確認ダイアログを表示
        reply = QMessageBox.question(
            self,
            "キャッシュのクリア",
            "データ取得期間が増えました。\n既存のシミュレーション結果を全てクリアして再計算しますか？",
            QMessageBox.Yes | QMessageBox.No
        )

        if reply == QMessageBox.Yes:
            self._clear_simulation_cache()
```

**期間値の変換:**
```python
def _get_period_value(self, period: str) -> int:
    period_map = {
        '1y': 1, '2y': 2, '5y': 5, '10y': 10,
        '15y': 15, '20y': 20, 'max': 9999
    }
    return period_map.get(period, 10)
```

**エラー修正:**
- 初回実装時、`self.load_stocks()`を呼び出してエラー発生
- 正しいメソッド名は`self.load_initial_data()`に修正（line 1239）

**行番号:** `main_window_v3.py:1141-1171`, `1210-1243`

---

### 2. チャート表示バグの修正 ✅

#### 問題
銘柄を初めてクリックした時、期待リターン推移チャートが複数の折れ線でジグザグに表示される不具合がありました。2回目のクリックでは正しく表示されていました。

**スクリーンショット:**
- `sc01.png` - 初回クリック時（バグ発生）
- `sc02.png` - 2回目クリック時（正常表示）

#### 原因分析
`src/core/calculator.py`の`find_optimal_timing()`メソッドで以下の処理順になっていました：

1. Line 213-240: 1日前～120日前までバックテストを実行し、`all_results`配列に追加（日数順）
2. Line 249-250: 各結果にスコア計算（`expected_return * win_rate`）
3. Line 253: **スコア順にソート（降順）** ← ここで日数が非連続に（例: 90, 52, 103, 45...）
4. Line 254: 最適値（スコア最大）を取得
5. Line 257以降: チャート描画

**問題点:** matplotlibの`ax.plot()`は配列の順序通りに線を引くため、日数が非連続だとジグザグな線になる

**なぜ2回目は正常？**
2回目クリック時はデータベースの`simulation_cache`テーブルから取得するため、`buy_days_before`（日数）の昇順でソートされたデータが返される

#### 解決策
**実装ファイル:** `src/core/calculator.py`

**修正コード（Line 257追加）:**
```python
# スコアでソート
all_results.sort(key=lambda x: x['score'], reverse=True)
optimal = all_results[0]

# 【追加】チャート描画のため、日数順に戻す
all_results.sort(key=lambda x: x['days_before'])
```

**結果:** 初回クリックから正しい折れ線グラフを表示

**デバッグ過程:**
- `chart_widget.py`と`detail_panel.py`に詳細なログ出力を追加
- `all_results`の内容とソート順を確認
- 原因特定後、デバッグログは全て削除

**行番号:** `calculator.py:257`

---

### 3. 詳細パネルのUI/UX改善 ✅

#### 問題
**スクリーンショット:** `sc03.png`, `sc04.png`

ユーザーから以下の改善要望がありました：
1. 統計値のテキストが枠線にくっついている（マージン不足）
2. 情報カードが縦レイアウトで縦長すぎる
3. 「詳細統計」ヘッダーとデータ行の左端が揃っていない
4. 銘柄名と証券コードの左右マージンが不足

#### 解決策
**実装ファイル:** `src/ui/widgets/detail_panel.py`

##### (1) 統計ラベルのマージン追加
**Line 83-103: `_create_stat_label()`メソッド修正**

**変更前:**
```python
container_layout.setContentsMargins(0, 0, 0, 0)
```

**変更後:**
```python
container_layout.setContentsMargins(10, 8, 10, 8)
```

##### (2) 統計行のマージン調整
**Line 105-122: `_create_stat_row()`メソッド修正**

**変更前:**
```python
row_layout.setContentsMargins(0, 5, 0, 5)
```

**変更後:**
```python
row_layout.setContentsMargins(12, 6, 12, 6)
```

##### (3) 情報カードの横レイアウト化
**Line 83-103: `_create_stat_label()`メソッド修正**

**変更前:**
```python
container_layout = QVBoxLayout(container)  # 縦並び
container_layout.addWidget(title_label)    # タイトル
container_layout.addWidget(value_label)    # 値
```

**変更後:**
```python
container_layout = QHBoxLayout(container)  # 横並び
container_layout.addWidget(title_label)    # タイトル（左）
container_layout.addStretch()              # スペーサー
container_layout.addWidget(value_label)    # 値（右）
```

**フォントサイズ統一:**
- タイトル: 10pt
- 値: 10pt（以前は12pt）

##### (4) 銘柄名のマージン追加
**Line 44-63: 銘柄名表示部分**

**変更:**
```python
# 銘柄名をコンテナで囲み、左右マージンを追加
title_container = QWidget()
title_layout = QHBoxLayout(title_container)
title_layout.setContentsMargins(12, 0, 12, 0)
title_layout.addWidget(self.name_label)
```

##### (5) 証券コードのバッジスタイル化
**Line 58-67: 証券コード表示**

**追加スタイル:**
```python
self.code_label.setStyleSheet("""
    QLabel {
        color: #B0B0B0;
        font-size: 10pt;
        font-weight: 500;
        border: none;
        background-color: #3A3A3A;
        border-radius: 12px;
        padding: 4px 12px;
    }
""")
```

**左右マージン追加:**
```python
code_container_layout.setContentsMargins(12, 0, 12, 0)
```

##### (6) 詳細統計ヘッダーの整列
**Line 205-218: 詳細統計セクション**

**変更:**
```python
# ヘッダーをコンテナで囲み、データ行と同じマージンを適用
title_container = QWidget()
title_layout = QHBoxLayout(title_container)
title_layout.setContentsMargins(12, 6, 12, 6)  # データ行と同じ
title_layout.addWidget(title_label)
```

**結果:**
- 統一感のあるマージン（横: 12px, 縦: 6-8px）
- ヘッダーとデータの左端が完全に揃う
- モダンなバッジデザイン
- スペース効率の向上

---

### 4. データ更新機能の実装 ✅

#### 背景
Phase 6完了時、右上の「データ更新」ボタンは未実装（プレースホルダーメッセージのみ）でした。難易度評価は**中程度（★★★☆☆）**、推定実装時間は**2.5-4時間**でした。

#### 実装内容
**実装ファイル:** `src/ui/main_window_v3.py`

##### (1) DataRefreshWorkerSignals クラス
**Line 103-108:**
```python
class DataRefreshWorkerSignals(QObject):
    """データ更新ワーカー用シグナル"""
    finished = Signal(dict)  # 完了時: {total, success, errors, stocks}
    error = Signal(str)      # エラー時: エラーメッセージ
```

##### (2) DataRefreshWorker クラス
**Line 110-194:**

**初期化:**
```python
class DataRefreshWorker:
    def __init__(self):
        self.signals = DataRefreshWorkerSignals()
        self._thread = None
        self.logger = logging.getLogger(__name__)
```

**finished プロパティ:**
```python
@property
def finished(self):
    """finishedシグナルへのアクセス"""
    return self.signals.finished
```

**スレッド開始:**
```python
def start(self):
    """バックグラウンドスレッドを開始"""
    self._thread = threading.Thread(target=self._run, daemon=True)
    self._thread.start()
```

**メイン処理:**
```python
def _run(self):
    """バックグラウンドでデータ更新を実行"""
    manager = None
    db = None

    try:
        # ScraperManagerでスクレイピング実行
        manager = ScraperManager()
        stocks = manager.scrape_with_fallback(month=None)

        if not stocks:
            self.signals.error.emit("データ取得に失敗しました")
            return

        # データベースに保存
        db = DatabaseManager()
        success_count = 0
        error_count = 0

        for stock in stocks:
            try:
                db.save_stock(stock)
                success_count += 1
            except Exception as e:
                error_count += 1

        # 成功シグナル送信
        self.signals.finished.emit({
            'total': len(stocks),
            'success': success_count,
            'errors': error_count,
            'stocks': stocks
        })

    except Exception as e:
        self.signals.error.emit(str(e))

    finally:
        # リソースクリーンアップ
        if manager:
            manager.close()
        if db:
            db.close()
```

**重要ポイント:**
- `threading.Thread`を使用（macOS SQLite互換性のため、QThreadは使用しない）
- `daemon=True`でメインスレッド終了時に自動終了
- `finally`ブロックで確実にリソースをクローズ

##### (3) データ更新ハンドラ
**Line 1036-1133:**

**on_refresh_data() メソッド:**
```python
def on_refresh_data(self):
    """データ更新ボタンクリック時の処理"""
    # 確認ダイアログ
    reply = QMessageBox.question(
        self,
        "データ更新",
        "優待銘柄データを更新します。\n"
        "ウェブスクレイピングを実行しますがよろしいですか？\n\n"
        "注意: 処理に時間がかかる場合があります。",
        QMessageBox.Yes | QMessageBox.No
    )

    if reply != QMessageBox.Yes:
        return

    # プログレスダイアログ表示
    self.progress_dialog = QProgressDialog(
        "データを更新中...",
        "キャンセル",
        0, 0,  # 不定形プログレスバー
        self
    )
    self.progress_dialog.setWindowTitle("データ更新")
    self.progress_dialog.setWindowModality(Qt.WindowModal)
    self.progress_dialog.setCancelButton(None)  # キャンセル不可
    self.progress_dialog.show()

    # DataRefreshWorker開始
    self.current_data_refresh_worker = DataRefreshWorker()
    self.current_data_refresh_worker.finished.connect(
        self.on_data_refresh_finished
    )
    self.current_data_refresh_worker.signals.error.connect(
        self.on_data_refresh_error
    )
    self.current_data_refresh_worker.start()
```

**on_data_refresh_finished() メソッド:**
```python
def on_data_refresh_finished(self, result: Dict):
    """データ更新完了時の処理"""
    # プログレスダイアログを閉じる
    if hasattr(self, 'progress_dialog'):
        self.progress_dialog.close()

    # 成功メッセージ表示
    total = result.get('total', 0)
    success = result.get('success', 0)
    errors = result.get('errors', 0)

    QMessageBox.information(
        self,
        "データ更新完了",
        f"データ更新が完了しました。\n\n"
        f"合計: {total}件\n"
        f"成功: {success}件\n"
        f"エラー: {errors}件"
    )

    # 銘柄リストを再読み込み
    self.load_initial_data()
```

**on_data_refresh_error() メソッド:**
```python
def on_data_refresh_error(self, error_msg: str):
    """データ更新エラー時の処理"""
    if hasattr(self, 'progress_dialog'):
        self.progress_dialog.close()

    QMessageBox.critical(
        self,
        "データ更新エラー",
        f"データ更新中にエラーが発生しました：\n\n{error_msg}"
    )
```

##### (4) 初期化処理の追加
**Line 74（__init__メソッド内）:**
```python
self.current_data_refresh_worker = None
```

#### 動作フロー
1. ユーザーが「データ更新」ボタンをクリック
2. 確認ダイアログ表示
3. プログレスダイアログ（不定形）表示
4. DataRefreshWorkerをバックグラウンドスレッドで起動
5. ScraperManagerで複数サイトからスクレイピング（フォールバック戦略）
6. 取得したデータをDatabaseManagerで保存
7. 完了シグナル送信
8. プログレスダイアログを閉じ、結果ダイアログ表示
9. 銘柄リストを自動リロード

#### 技術的特徴
- **非同期処理:** UIがフリーズしない
- **エラーハンドリング:** try-except-finallyで堅牢
- **リソース管理:** manager.close()とdb.close()を確実に実行
- **macOS対応:** threading.Thread使用でSQLiteクラッシュを回避
- **ユーザーフィードバック:** 詳細な成功/エラーメッセージ

---

## 📊 変更ファイル一覧

### コアファイル
| ファイル | 変更内容 | 行数変更 |
|---------|---------|----------|
| `src/core/calculator.py` | チャート表示バグ修正（line 257追加） | +1 |

### UIファイル
| ファイル | 変更内容 | 行数変更 |
|---------|---------|----------|
| `src/ui/main_window_v3.py` | キャッシュ無効化機能追加 | +33 |
| | DataRefreshWorker追加 | +92 |
| | データ更新ハンドラ追加 | +98 |
| | **合計** | **+223** |
| `src/ui/widgets/detail_panel.py` | 情報カードレイアウト変更 | ~20 |
| | マージン最適化 | ~15 |
| | ヘッダー整列 | ~13 |
| | バッジスタイル追加 | ~10 |
| | **合計** | **~58** |

### ドキュメント
| ファイル | 変更内容 |
|---------|---------|
| `CHANGELOG.md` | v1.1.0セクション追加（62行） |
| `docs/dev_log_2025-12-25.md` | 本ファイル作成（新規） |

**総変更行数:** 約 **282行** （コード）+ **62行** （ドキュメント）= **344行**

---

## 🐛 発生したエラーと修正

### エラー #1: AttributeError - load_stocks メソッドが存在しない
**発生箇所:** `main_window_v3.py:1239`（`_clear_simulation_cache()`メソッド内）

**エラーメッセージ:**
```
AttributeError: 'MainWindow' object has no attribute 'load_stocks'
```

**原因:**
キャッシュクリア後のリロード処理で、存在しないメソッド`self.load_stocks()`を呼び出していた

**修正:**
```python
# 修正前
self.load_stocks()

# 修正後
self.load_initial_data()
```

**影響範囲:** 軽微（即座に修正）

---

## 🎯 成果

### 機能追加
- ✅ データ更新機能の完全実装
- ✅ 設定変更時の自動キャッシュ無効化

### バグ修正
- ✅ チャート表示バグ修正（初回クリック時のジグザグ線）

### UI/UX改善
- ✅ 詳細パネルのマージン最適化
- ✅ 情報カードの横レイアウト化
- ✅ 証券コードのバッジスタイル化
- ✅ 統計ヘッダーとデータの整列

### ドキュメント
- ✅ CHANGELOG.md更新（v1.1.0追加）
- ✅ 開発ログ作成（本ファイル）

---

## 🧪 テスト状況

### 手動テスト結果

#### 1. キャッシュ無効化機能
- ✅ 設定で期間を「10y」→「max」に変更 → 確認ダイアログ表示
- ✅ 「はい」選択 → キャッシュクリア + データリロード成功
- ✅ 設定で期間を「max」→「10y」に変更 → ダイアログ表示されない（正常）

#### 2. チャート表示
- ✅ 初回クリック時、正しい折れ線グラフを表示
- ✅ 2回目クリック時も同じグラフを表示（キャッシュ動作確認）

#### 3. UI改善
- ✅ 情報カードが横レイアウトで表示
- ✅ マージンが統一され、読みやすい
- ✅ ヘッダーとデータの左端が揃っている
- ✅ 証券コードがバッジスタイルで表示

#### 4. データ更新機能
- ✅ 確認ダイアログ表示
- ✅ プログレスダイアログ表示
- ✅ スクレイピング実行
- ✅ データベース保存成功
- ✅ 完了メッセージ表示（合計数、成功数、エラー数）
- ✅ 銘柄リスト自動リロード

**テスト環境:** Windows 11, Python 3.10, PySide6

---

## 💡 技術的ハイライト

### 1. matplotlibの配列順依存性
matplotlib.pyplot.plot()は、データの配列順にそのまま線を引くため、X軸の値がソートされていない場合、意図しないジグザグ線になる。チャート描画前に必ずX軸でソートする必要がある。

### 2. macOS環境でのSQLite + QThread問題
macOSでは、QThreadとSQLiteを併用するとSIGSEGVクラッシュが発生する既知の問題がある。解決策として、Python標準の`threading.Thread`とQObjectのシグナルを組み合わせることで、Qt UIとの通信を保ちながら安全に非同期処理を実装できる。

### 3. リソース管理の重要性
バックグラウンドスレッドでのデータベース接続やネットワークリソースは、try-finally構文で確実にクローズする。特に例外発生時にリソースがリークしないよう注意が必要。

### 4. UI/UXの一貫性
マージンを統一することで、視覚的な一貫性と読みやすさが大幅に向上する。本日の改善では、横マージン12px、縦マージン6-8pxに統一し、プロフェッショナルな見た目を実現。

---

## 📈 メトリクス

### コード変更
- **追加行数:** 282行
- **変更ファイル数:** 3ファイル
- **新規メソッド数:** 7メソッド
- **新規クラス数:** 2クラス（DataRefreshWorkerSignals, DataRefreshWorker）

### ドキュメント
- **更新ファイル数:** 1ファイル（CHANGELOG.md）
- **新規ファイル数:** 1ファイル（本ファイル）
- **追加行数:** 約62行（CHANGELOG）

### バグ修正
- **修正バグ数:** 2件
  - チャート表示バグ
  - AttributeError（load_stocksメソッド）

### UI改善
- **改善箇所:** 6箇所
  - 統計ラベルマージン
  - 統計行マージン
  - 情報カードレイアウト
  - 銘柄名マージン
  - 証券コードバッジ
  - 詳細統計ヘッダー整列

---

## 🚀 今後の課題

### 短期（次回セッション）
- [ ] データ更新機能のキャンセル対応
- [ ] データ更新中の進捗率表示（現在は不定形）
- [ ] スクレイピングのエラーログ詳細化

### 中期（v1.2.0）
- [ ] ポートフォリオ管理機能
- [ ] 複数銘柄の比較機能
- [ ] バックテスト期間のカスタマイズUI

### 長期（v2.0.0）
- [ ] リスク分析（シャープレシオ、最大ドローダウン）
- [ ] APIによる外部連携
- [ ] 多言語対応（英語）

---

## ✅ まとめ

v1.1.0では、以下を達成しました：

1. **ユーザー体験の向上**
   - データ更新機能が使えるようになり、ユーザー自身で最新データを取得可能
   - 設定変更時に自動でキャッシュ無効化を提案し、混乱を防止

2. **バグの解消**
   - チャート表示バグを修正し、初回から正しいグラフを表示

3. **UI/UXの洗練**
   - マージンの最適化により、読みやすく美しいUIを実現
   - 情報カードの横レイアウト化でスペース効率が向上

4. **技術的品質の向上**
   - macOS対応のスレッド処理
   - 適切なリソース管理
   - 堅牢なエラーハンドリング

**実装時間:** 約4時間
**コード品質:** ✅ 高品質
**ドキュメント:** ✅ 完備
**テスト:** ✅ 手動テスト完了

---

**作成者:** Yuutai Event Investor Team
**最終更新:** 2025-12-25
**次回バージョン予定:** v1.2.0（機能追加フェーズ）
